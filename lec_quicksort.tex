\PassOptionsToPackage{unicode}{hyperref}
\documentclass[aspectratio=1610, 11pt]{beamer}

\usepackage{amsmath}
\usepackage{amssymb}
\usetheme{tudo}

\title{Datenstrukturen, Algorithmen und Prorammierung~2}
\author[A.~Coja-Oghlan]{Amin Coja-Oghlan}
\institute[DAP2]{Lehrstuhl Informatik 2\\Fakult\"at f\"ur Informatik}

\newcommand\dd{\mathrm d}
\newcommand\eul{\mathrm e}

\newcommand\cA{\mathcal A}
\newcommand\cB{\mathcal B}
\newcommand\cC{\mathcal C}
\newcommand\cD{\mathcal D}
\newcommand\cE{\mathcal E}
\newcommand\cF{\mathcal F}
\newcommand\cG{\mathcal G}
\newcommand\cH{\mathcal H}
\newcommand\cI{\mathcal I}
\newcommand\cJ{\mathcal J}
\newcommand\cK{\mathcal K}
\newcommand\cL{\mathcal L}
\newcommand\cM{\mathcal M}
\newcommand\cN{\mathcal N}
\newcommand\cO{\mathcal O}
\newcommand\cP{\mathcal P}
\newcommand\cQ{\mathcal Q}
\newcommand\cR{\mathcal R}
\newcommand\cS{\mathcal S}
\newcommand\cT{\mathcal T}
\newcommand\cU{\mathcal U}
\newcommand\cV{\mathcal V}
\newcommand\cW{\mathcal W}
\newcommand\cX{\mathcal X}
\newcommand\cY{\mathcal Y}
\newcommand\cZ{\mathcal Z}

\newcommand\fA{\mathfrak A}
\newcommand\fB{\mathfrak B}
\newcommand\fC{\mathfrak C}
\newcommand\fD{\mathfrak D}
\newcommand\fE{\mathfrak E}
\newcommand\fF{\mathfrak F}
\newcommand\fG{\mathfrak G}
\newcommand\fH{\mathfrak H}
\newcommand\fI{\mathfrak I}
\newcommand\fJ{\mathfrak J}
\newcommand\fK{\mathfrak K}
\newcommand\fL{\mathfrak L}
\newcommand\fM{\mathfrak M}
\newcommand\fN{\mathfrak N}
\newcommand\fO{\mathfrak O}
\newcommand\fP{\mathfrak P}
\newcommand\fQ{\mathfrak Q}
\newcommand\fR{\mathfrak R}
\newcommand\fS{\mathfrak S}
\newcommand\fT{\mathfrak T}
\newcommand\fU{\mathfrak U}
\newcommand\fV{\mathfrak V}
\newcommand\fW{\mathfrak W}
\newcommand\fX{\mathfrak X}
\newcommand\fY{\mathfrak Y}
\newcommand\fZ{\mathfrak Z}

\newcommand\fa{\mathfrak a}
\newcommand\fb{\mathfrak b}
\newcommand\fc{\mathfrak c}
\newcommand\fd{\mathfrak d}
\newcommand\fe{\mathfrak e}
\newcommand\ff{\mathfrak f}
\newcommand\fg{\mathfrak g}
\newcommand\fh{\mathfrak h}
%\newcommand\fi{\mathfrak i}
\newcommand\fj{\mathfrak j}
\newcommand\fk{\mathfrak k}
\newcommand\fl{\mathfrak l}
\newcommand\fm{\mathfrak m}
\newcommand\fn{\mathfrak n}
\newcommand\fo{\mathfrak o}
\newcommand\fp{\mathfrak p}
\newcommand\fq{\mathfrak q}
\newcommand\fr{\mathfrak r}
\newcommand\fs{\mathfrak s}
\newcommand\ft{\mathfrak t}
\newcommand\fu{\mathfrak u}
\newcommand\fv{\mathfrak v}
\newcommand\fw{\mathfrak w}
\newcommand\fx{\mathfrak x}
\newcommand\fy{\mathfrak y}
\newcommand\fz{\mathfrak z}

\newcommand\vA{\vec A}
\newcommand\vB{\vec B}
\newcommand\vC{\vec C}
\newcommand\vD{\vec D}
\newcommand\vE{\vec E}
\newcommand\vF{\vec F}
\newcommand\vG{\vec G}
\newcommand\vH{\vec H}
\newcommand\vI{\vec I}
\newcommand\vJ{\vec J}
\newcommand\vK{\vec K}
\newcommand\vL{\vec L}
\newcommand\vM{\vec M}
\newcommand\vN{\vec N}
\newcommand\vO{\vec O}
\newcommand\vP{\vec P}
\newcommand\vQ{\vec Q}
\newcommand\vR{\vec R}
\newcommand\vS{\vec S}
\newcommand\vT{\vec T}
\newcommand\vU{\vec U}
\newcommand\vV{\vec V}
\newcommand\vW{\vec W}
\newcommand\vX{\vec X}
\newcommand\vY{\vec Y}
\newcommand\vZ{\vec Z}

\newcommand\va{\vec a}
\newcommand\vb{\vec b}
\newcommand\vc{\vec c}
\newcommand\vd{\vec d}
\newcommand\ve{\vec e}
\newcommand\vf{\vec f}
\newcommand\vg{\vec g}
\newcommand\vh{\vec h}
\newcommand\vi{\vec i}
\newcommand\vj{\vec j}
\newcommand\vk{\vec k}
\newcommand\vl{\vec l}
\newcommand\vm{\vec m}
\newcommand\vn{\vec n}
\newcommand\vo{\vec o}
\newcommand\vp{\vec p}
\newcommand\vq{\vec q}
\newcommand\vr{\vec r}
\newcommand\vs{\vec s}
\newcommand\vt{\vec t}
\newcommand\vu{\vec u}
\renewcommand\vv{\vec v}
\newcommand\vw{\vec w}
\newcommand\vx{\vec x}
\newcommand\vy{\vec y}
\newcommand\vz{\vec z}

\renewcommand\AA{\mathbb A}
\newcommand\NN{\mathbb N}
\newcommand\ZZ{\mathbb Z}
\newcommand\PP{\mathbb P}
\newcommand\QQ{\mathbb Q}
\newcommand\RR{\mathbb R}
\newcommand\RRpos{\mathbb R_{\geq0}}
\renewcommand\SS{\mathbb S}
\newcommand\CC{\mathbb C}

\newcommand{\ord}{\mathrm{ord}}
\newcommand{\id}{\mathrm{id}}
\newcommand{\pr}{\mathrm{P}}
\newcommand{\Vol}{\mathrm{vol}}
\newcommand\norm[1]{\left\|{#1}\right\|} 
\newcommand\sign{\mathrm{sign}}
\newcommand{\eps}{\varepsilon}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand\bc[1]{\left({#1}\right)} 
\newcommand\cbc[1]{\left\{{#1}\right\}} 
\newcommand\bcfr[2]{\bc{\frac{#1}{#2}}} 
\newcommand{\bck}[1]{\left\langle{#1}\right\rangle} 
\newcommand\brk[1]{\left\lbrack{#1}\right\rbrack} 
\newcommand\scal[2]{\bck{{#1},{#2}}} 
\newcommand{\vecone}{\mathbb{1}}
\newcommand{\tensor}{\otimes}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\ggt}{\mathrm{ggT}}
\newcommand{\kgv}{\mathrm{kgV}}
\newcommand{\trans}{\top}

\newcommand{\Karonski}{Karo\'nski}
\newcommand{\Erdos}{Erd\H{o}s}
\newcommand{\Renyi}{R\'enyi}
\newcommand{\Lovasz}{Lov\'asz}
\newcommand{\Juhasz}{Juh\'asz}
\newcommand{\Bollobas}{Bollob\'as}
\newcommand{\Furedi}{F\"uredi}
\newcommand{\Komlos}{Koml\'os}
\newcommand{\Luczak}{\L uczak}
\newcommand{\Kucera}{Ku\v{c}era}
\newcommand{\Szemeredi}{Szemer\'edi}


\begin{document}

\maketitle

\begin{frame}{Quicksort}
	\begin{block}{Ziel}
			Eine Liste $L=(\ell_1,\ldots,\ell_n)$ \alert{vergleichbarer} Elemente aufsteigend sortieren.
	\end{block}
\begin{exampleblock}{Vergleichbarkeit}
	\begin{itemize}
		\item f\"ur je zwei Element $\ell_i,\ell_j$ gilt entweder $\ell_i<\ell_j$, $\ell_i=\ell_j$ oder $\ell_i>\ell_j$
		\item die Ordnung ist \alert{transitiv}: $\ell_h\leq\ell_i$ und $\ell_i\leq\ell_j$ $\Rightarrow$ $\ell_h\leq\ell_j$
	\item die Ordnung ist \alert{antisymmetrisch}: $\ell_i\leq\ell_j$ und $\ell_j\leq\ell_i$ $\Rightarrow$ $\ell_i=\ell_j$
	\item wir haben Zugriff auf eine Funktion, die zwei Element $\ell_i,\ell_j$ vergleicht
	\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}{Quicksort}
\begin{exampleblock}{Beispiele}
	\begin{itemize}
		\item ganze, rationale oder reelle Zahlen mit der gew\"ohnlichen Ordnung
		\item Zeichenketten mit alphabetischer Ordnung
		\item Punkte in $\RR^2$ mit lexikographischer Ordnung
	\end{itemize}
\end{exampleblock}
\begin{exampleblock}{Effiziente, generische Sortieralgorithmen}
	\begin{itemize}
		\item Laufzeit $=$ Zahl der \alert{Vergleiche}, die der Algorithmus durchf\"uhrt
		\item der Algorithmus darf Elemente \emph{nur} miteinander vergleichen
		\item dadurch ist der Algorithmus auf beliebige vergleichbare Objekte anwendbar
	\end{itemize}
\end{exampleblock}
\end{frame}

\begin{frame}{Quicksort}
\begin{exampleblock}{Algorithmus \tt Quicksort}
	\begin{enumerate}
		\item F\"ur $i=1,\ldots,n$
		\item $\quad$falls $\ell_i<\ell_1$, f\"uge $\ell_i$ der Liste $K$ hinzu.
		\item $\quad$falls $\ell_i>\ell_1$, f\"uge $\ell_i$ der Liste $G$ hinzu.
		\item $\quad$falls $\ell_i=\ell_1$, f\"uge $\ell_i$ der Liste $M$ hinzu.
		\item Wende {\tt Quicksort} rekursiv an, um $K$ und $G$ zu sortieren.
		\item Gib $K,M,G$ aus.
	\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}{Quicksort}
\begin{exampleblock}{Implementation: Sortieren an Ort und Stelle}
	\begin{itemize}
		\item wir implementieren {\tt Quicksort}, indem die Elemente in der Eingabeliste miteinander vertauscht werden
		\item dazu verwenden wir Dijkstra's Partitionierungsverfahren
		\item dieses vertausche die Elemente des Arrays wie folgt
		\item gegeben ist ein Array $A$ der L\"ange $n$; Pivot ist Element $A[0]$
		\item Eintr\"age $0$ bis ausschlie\ss lich $i$ sind kleiner als das Pivot
		\item Eintr\"age $i$ bis ausschlie\ss lich $j$ sind gleich dem Pivot
		\item Eintr\"age $k+1$ bis $n-1$ sind gr\"o\ss er als das Pivot
		\item \em Beachte: die Indizierung der Eintr\"age beginnt bei 0 und endet bei $n-1$
	\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}{Quicksort}
\begin{exampleblock}{Dijkstra-Partitionierung}
	\begin{enumerate}
		\item setze $i=0$, $j=0$, $k=n-1$
		\item solange $j\leq k$
		\item $\quad$falls $A[j]<\mbox{pivot}$
		\item $\qquad$vertausche $A[i]$ und $A[j]$
		\item $\qquad$erh\"ohe $i$ und $j$ um $1$
		\item $\quad$sonst, wenn $A[j]>\mbox{pivot}$
		\item $\qquad$vertausche $A[j]$ und $A[k]$
		\item $\qquad$verringere $k$ um $1$
		\item $\quad$sonst erh\"ohe $j$ um $1$
	\end{enumerate}
	\end{exampleblock}
\end{frame}

\begin{frame}{Quicksort}
\begin{exampleblock}{Beispiel: Dijkstra-Partitionierung}
		Wir sortieren $(2,4,6,1,3,5,2)$ mit Pivot 2:
			\begin{align*}
				(2,4,6,1,3,5,2)&&i=0,\ j=0,\ k=6\\
				(2,4,6,1,3,5,2)&&i=0,\ j=\textcolor{red}1,\ k=6\\
				(2,\textcolor{red}2,6,1,3,5,\textcolor{red}4)&&i=0,\ j=1,\ k=\textcolor{red}5\\
				(2,2,6,1,3,5,4)&&i=0,\ j=\textcolor{red}2,\ k=5\\
				(2,2,\textcolor{red}5,1,3,\textcolor{red}6,4)&&i=0,\ j=2,\ k=\textcolor{red}4\\
				(2,2,\textcolor{red}3,1,\textcolor{red}5,6,4)&&i=0,\ j=2,\ k=\textcolor{red}3\\
				(2,2,\textcolor{red}1,\textcolor{red}3,5,6,4)&&i=0,\ j=2,\ k=\textcolor{red}2\\
				(\textcolor{red}1,2,\textcolor{red}2,3,5,6,4)&&i=\textcolor{red}1,\ j=2,\ k=2\\
				(1,2,2,3,5,6,4)&&i=1,\ j=\textcolor{red}3,\ k=2
			\end{align*}
	\end{exampleblock}
\end{frame}

\begin{frame}{Quicksort}
\begin{exampleblock}{Worst case-Laufzeit}
	\begin{itemize}
		\item die schlechteste Laufzeit ergibt sich, wenn die Eingabe bereits sortiert ist!
		\item in diesem Fall wird jedesmal das Pivot mit allen Elementen verglichen
		\item die Laufzeit ist daher
			\begin{align*}
				\sum_{i=1}^ni&=\frac{n(n+1)}2
			\end{align*}
		\item trotzdem begegnet Quicksort in der Praxis h\"aufig
		\item wir werden im weiteren entdecken, warum
	\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}{Quicksort}
\begin{exampleblock}{Zusammenfassung}
	\begin{itemize}
		\item Quicksort sortiert eine Eingabeliste vergleichbarer Elemente
		\item die Sortierung erfolgt an Ort und Stelle
		\item die Laufzeit ist im schlimmsten Fall $n(n+1)/2$
	\end{itemize}
	\end{exampleblock}
\end{frame}

\end{document}
